#!/usr/bin/perl -w

=head1 NAME

milli - A bug recording system; suitable for distributed use.

=cut

=head1 SYNOPSIS

  milli [options] sub-command [args]

  available sub-commands:

    add                 - Add a new bug.
    append              - Append text to an existing bug.
    close               - Change an open bug to a closed state.
    closed              - List all closed bugs.
    edit                - Allow a bug to be edited.
    import              - Create a new bug, via parsing the email on STDIN
    init                - Initialise the system.
    list|search         - Display existing bugs.
    open                - List all currently open bugs.
    priority            - Edit the priority of bugs.
    reopen              - Change a closed bug to open.
    view                - Show all details about a specific bug.

  Options:
    --editor            - Specify which editor to use.
    --message           - Use the given message rather than spawning an editor.
    --priority          - Restrict matches when searching.
    --state             - Restrict matches when searching.
    --verbose           - Show UID when listing/searching.

=cut

=head1 ABOUT

milli is an intentionally simple system which allows bugs to be stored
inside projects, and merged in along with all other changes in exactly the
way that a user of a distributed revision control system would expect.

In short a project will have any and all bugs stored beneath the B<.milli>
directory, which is assumed to be part of the revision control system
repository.

All bugs will be stored in random, but hostname-sepcific, filename such
that multiple people merging and commiting will be unlikely to ever see
conflicts.

=cut

=head1 WHAT ARE BUGS?

As noted above bugs are stored in simple text files, with a small header
which stores several pieces of meta-information:

  * The date/time the bug was changed.
  * The title of the bug.
  * The bug state & priority.
  * Any comments the user has chosen to make upon the bug.

Bug states and priorities are handled in a very simple fashion, with both
of them being nothing more than simple text labels.  If the defaults do
not sue then you may define your own statuses or priorities, but by default
you will find the following are present:

=for example begin

 Default states:
  * open.
  * closed.

 Default priorities:
  * low
  * normal
  * high

=for example end

Each bug also has its own associated UID, which is unique and global.

For convience when listing and searching bugs each will be displayed with
a "bug number".  This bug number is entirely an artificial construct
which is local-only.

The UID associated with a bug will be fixed at the time it is created, but
the number will almost change over time when additional bugs are added.
For that reason it is stable between "list" and "search" operations and
may be used to update, add comments, or close until a new bug is added
at which point a further "list" operation may show that it has changed.

=cut

=head1 USING IT

Usage of milli is divided into several distinct use-cases:

  * Initialising a new project.
  * Adding a new bug.
  * Searching for bugs.
  * Viewing a single specific bug.
  * Updating a single specific bug, or appending to an existing bug report.
  * Closing and re-opening a bug.

These actions all work in a consistent manner, to avoid unpleasant suprises.

=cut


=head1 USAGE EXAMPLES

To initialise a bug database within your project run:

=for example begin

   milli init

=for example end

Once you've initialised your milli database you will need to ensure that
you add the B<.milli> directory to your revision control system.

To add a new bug, optionally specifying a title for it, please run:

=for example begin

   milli add This is my bug title

=for example end

If no title is specified a bug report will be created with a sensible default.

Once a bug has been added it will be presented to you in an editor, this will
allow you to enter the actual bug text.  (Unless you specified a message with
B<--message>).

The editer may be specified with the B<--editor> flag, the EDITOR environmental
variable.  If neither are specified then milli will default to B<vim>.

Once a bug report has been created you should find that it is visible in the
output of "milli list" or "milli open".  In both cases you'll see output which
looks something like this:

=for example begin

  N:0001 [closed] testing milli
  N:0002 [closed] This is a test
  N:0003 [  open] This is my bug title

=for example end

This listing report shows three things:  The number of the bug, the state
of the bug ("open" vs. "closed") and the title of the bug.

Each of the operations that is specific to a single bug report will allow you
to specify the number of the bug.  For example if you wished to update the
last bug, to append some text to it, you could run:

=for example begin

  milli append 3

=for example end

Similarly you could close the bug by running:

=for example begin

  milli close 3

=for example end

Note that to close a bug you do not need to give a justification, or add
any content.  A bug may go from freshly opened to closed with no need for
further updates.

=cut


=head1 BUG FILE FORMAT

Internally each bug is stored in a file, beneath the B<.milli> directory.

Each bug file has a random name which is designed to avoid potential collisions
if a repository is shared between many users, upon different systems, as is
common with distributed revision controls.

Each bug report will have several fixed fields at the beginning, as this
example shows:

=for example begin

   Title: This is atest
   UID: 1269990083.P10668M151020.birthday.my.flat
   Added: Wed Mar 31 00:01:23 2010
   Status: open
   Priority: normal

   I like pies, but I have none.

=for example end

The UID is essentially random, but should be unique, and is the portable
sane way to refer to bugs.  When running B<milli list> you'll see a number
reported next to each bug, but this number is valid only for the local system
and may change when new bugs are reported.

In short you may use the displayed "bug number" for carrying out local
operations providing you realise that the number associated with a specific
bug will change over time.  By contrast the UID will never change, so you
may always run a command like this:

=for example begin

  milli view 1270024997.P15442M277230.birthday.my.flat

=for example end

=cut

=head1 CUSTOMIZATION

The template which is presented to the user when they report a new bug
may be replaced.  If the file ".milli/template" is present the contents
of that file will be inserted in new reports, rather than the default message.

If the file B<.milli/hook> exists, and is executable, it will be invoked
when new bugs are added, bugs are closed, or comments are updated.

The hook will be invoked with two arguments, the first will be a string
defining the action which has caused the invocation, the second will be
the name of the bug file.  For example you might use this to auto-add
new bug reports to the repository with a hook like this:

=for example begin

   #!/bin/sh
   if [ "$1" = "add" ]; then
       hg add "$2"
       hg commit --message "New bug added" "$2"
   fi

=for example end

=cut

=head1 AUTHOR

 Steve
 --
 http://www.steve.org.uk/

=cut

=head1 LICENSE

Copyright (c) 2010 by Steve Kemp.  All rights reserved.

This module is free software;
you can redistribute it and/or modify it under
the same terms as Perl itself.
The LICENSE file contains the full text of the license.

=cut


#
#  Pragmas
#
use strict;
use warnings;


#
#  Modules
#
use File::Path;
use Getopt::Long;
use Pod::Usage;
use Time::HiRes qw(gettimeofday);


#
#  The dispatch table mapping initial commands to the appropriate
# handler.
#
my %DISPATCH = createDispatch();



#
#  Configuration options
#
my %CONFIG;


#
#  Setup default options
#
setupDefaultOptions();


#
#  Parse configuration file, if present.
#
parseConfigurationFile();


#
#  Parse any command line options.
#
parseCommandLineArguments();




#
#  Ensure we received an argument.
#
my ( $cmd, @args ) = @ARGV;
if ( !defined($cmd) )
{
    usage();
}


#
#  Find the matching command entry in our dispatch table.
#
my $c = $DISPATCH{ $cmd };

#
#  If one was not found then we've been given an unrecognised option.
#
if ( !defined($c) )
{
    print "Unrecognised sub-command $cmd, valid commands are:\n\n";
    foreach my $k ( sort keys %DISPATCH )
    {
        print "\t$k\n";
    }
    print "\nFor more details please see 'milli --help', or 'milli --manual'\n";
    exit 1;
}


#
#  Otherwise call it.
#
$c->{ 'cmd' }->(@args);

#
#  All done
#
exit 0;




=begin doc

Create and return a hashtable to use as a sub-command dispatch table.

=end doc

=cut

sub createDispatch
{
    my %d = (
        "add"    => { cmd => \&cmd_add, },
        "append" => { cmd => \&cmd_append, },
        "close"  => { cmd => \&cmd_close, },
        "closed" => {
            cmd => sub {
                $CONFIG{ 'state' } = "closed";
                cmd_search(@_);
              }
        },
        "edit"   => { cmd => \&cmd_edit, },
        "import" => { cmd => \&cmd_import, },
        "init"   => { cmd => \&cmd_init, },
        "list"   => { cmd => \&cmd_search, },
        "open"   => {
                    cmd => sub {$CONFIG{ 'state' } = "open"; cmd_search(@_);}
                  },
        "priority" => { cmd => \&cmd_priority, },
        "reopen"   => { cmd => \&cmd_reopen, },
        "search"   => { cmd => \&cmd_search, },
        "view"     => { cmd => \&cmd_view, },
            );

    return (%d);
}



=begin doc

Setup the default options we'd expect.

=end doc

=cut

sub setupDefaultOptions
{

    #
    #  status
    #
    $CONFIG{ 'states' }         = "open, closed";
    $CONFIG{ 'default-status' } = "open";

    #
    #  priority
    #
    $CONFIG{ 'priorities' }       = "low, normal, high";
    $CONFIG{ 'default-priority' } = "normal";

    #
    #  More?
    #
}


=begin doc

Parse the command line options.

=end doc

=cut

sub parseCommandLineArguments
{
    my $HELP   = 0;
    my $MANUAL = 0;

    #
    #  Parse options.
    #
    if (
        !GetOptions(

            # Help options
            "help",    \$HELP,
            "manual",  \$MANUAL,
            "verbose", \$CONFIG{ 'verbose' },
            "force",   \$CONFIG{ 'force' },

            # Editor & message.
            "editor=s",  \$CONFIG{ 'editor' },
            "message=s", \$CONFIG{ 'message' },

            # state + priority used for search/list, status is a synonym
            "state=s",    \$CONFIG{ 'state' },
            "status=s",   \$CONFIG{ 'state' },
            "priority=s", \$CONFIG{ 'priority' },
        ) )
    {
        exit;
    }

    usage() if $HELP;
    pod2usage( -verbose => 2 ) if $MANUAL;
}



=begin doc

Parse the .mill/config file, if it is present.

=end doc

=cut

sub parseConfigurationFile
{
    my $dir = getMilliDirectory();


    return unless ( ( defined($dir) ) && ( -e "$dir/config" ) );

    my $line = "";

    open my $handle, "<", "$dir/config" or
      die "Cannot read .milli/config - $!";
    while ( defined( $line = <$handle> ) )
    {
        chomp $line;

        # Skip lines beginning with comments
        next if ( $line =~ /^([ \t]*)\#/ );

        # Skip blank lines
        next if ( length($line) < 1 );

        # Strip trailing comments.
        if ( $line =~ /(.*)\#(.*)/ )
        {
            $line = $1;
        }

        # Find variable settings
        if ( $line =~ /([^=]+)=([^\n]+)/ )
        {
            my $key = $1;
            my $val = $2;

            # Strip leading and trailing whitespace.
            $key =~ s/^\s+//;
            $key =~ s/\s+$//;
            $val =~ s/^\s+//;
            $val =~ s/\s+$//;

            # Store value.
            $CONFIG{ $key } = $val;
        }
    }

    close($handle);
}




=begin doc

Show the usage of this script and exit.

=end doc

=cut

sub usage
{
    pod2usage(1);
    exit 1;
}


###
###  Handlers for the commands.
###
#############################################################################


sub cmd_import
{

    #
    #  Headers we care about.
    #
    #  TODO: Read from .milli/config
    #
    my $headers = "subject,date,priority,from";

    #
    #  Read email, storing key+value pairs
    #
    my %headers;
    my $body;
    my $inheader = 1;

    while ( my $line = <STDIN> )
    {
        chomp($line);

        $inheader = 0 if ( $line =~ /^$/ );

        #
        #  Split the header.
        #
        #  TODO: Handle-multi-lines.
        #  TODO: Handle repeats
        #
        if ($inheader)
        {
            if ( $line =~ /^([^:]+):(.*)$/ )
            {
                my $key = $1;
                my $val = $2;
                $key = lc($key);

                $headers{ $key } = $val;
            }
        }
        else
        {
            $body .= $line . "\n";
        }
    }

    #
    #  The values we'll add
    #
    my $title = $headers{ 'subject' } || "Default titles";
    my $date  = $headers{ 'date' }    || scalar localtime;
    my $priority = $headers{ 'priority' } ||
      $CONFIG{ 'default-priority' } ||
      "normal";
    my $uid   = $headers{ 'message-id' }    || randomUID();
    my $state = $CONFIG{ 'default-status' } || "open";

    my $dir = getMilliDirectory();
    if ( !defined($dir) )
    {
        die ".milli directory not found\n";
    }

    my $file = "$dir/$uid.milli";


    #
    #  Write out the bug.
    #
    open( FILE, ">", $file ) or
      die "Failed to write to '$file' - $!";
    print FILE<<EOF;
Title: $title
UID: $uid
Added: $date
Priority: $priority
Status: $state

$body
EOF
}


=begin doc

Inititalise a new .milli directory.

=end doc

=cut

sub cmd_init
{
    if ( !-d ".milli" )
    {

        #
        #  Make the directory
        #
        mkpath( ".milli", { verbose => 0 } );

        #
        #  Create a stub file.
        #
        open( FILE, ">", ".milli/config" ) or
          die "Failed to write default file .milli/config: $!";
        print FILE <<EOF;

#
#  Each bug in the database has an associated state.
#
#  By default we support two states:
#
#   open    - The bug is still present.
#   closed  - The bug has been fixed.
#
#  You may create your own labels and choose which ones are supported by
# updating the following two settings:
#
states = open, closed
default-state = open

#
#
#  Each bug in the database may have an associated priority.
#
#  The labels you choose to asign to prorities may be specified here,
# and you may use an arbitrary number of them in order of "low" -> "high".
#
priorities = low, normal, high

#
#  Default priority to assign to new bugs.
#
default-priority = normal

EOF
        close(FILE);
        exit 0;
    }
    else
    {
        print "There is already a .milli/ directory present here.\n";
        exit 1;
    }
}


=begin doc

Add a new bug.

The arguments specified are the optional title.

=end doc

=cut

sub cmd_add
{
    my (@args) = (@_);

    #
    #  Ensure we have a .milli directory
    #
    my $dir = getMilliDirectory();
    if ( !defined($dir) )
    {
        if ( $CONFIG{ 'force' } )
        {
            $CONFIG{ 'verbose' } && print "Running 'milli init'.\n";
            cmd_init();
            $CONFIG{ 'verbose' } && print "Initialisation complete.\n";
        }
        else
        {
            print "Missing milli directory - run 'milli init' ?\n";
            print "Or add --force to run this automatically\n";
            exit 1;
        }
    }


    my $title = undef;
    if ( scalar(@args) )
    {
        $title = join( " ", @args );
    }

    $title = "Untitled bug report" unless ( defined($title) );

    #
    #  Make a "random" filename, with the same UID as the content.s
    #
    my $uid  = randomUID();
    my $file = "$dir/$uid.milli";

    my $date = scalar localtime;

    #
    #  Get the priority for new bugs.
    #
    my $priority = $CONFIG{ 'default-priority' } ||
      $CONFIG{ 'priority' } ||
      "normal";

    #
    #  Ditto the state.
    #
    my $state = $CONFIG{ 'default-state' } ||
      $CONFIG{ 'state' } ||
      "open";

    #
    #  Write our template to it
    #
    open( FILE, ">", $file ) or
      die "Failed to write to '$file' - $!";
    print FILE<<EOF;
Title: $title
UID: $uid
Added: $date
Priority: $priority
Status: $state

EOF


    #
    #  If we were given a message, add it to the file, and return without
    # invoking the editor.
    #
    if ( $CONFIG{ 'message' } )
    {
        print FILE $CONFIG{ 'message' };
        print FILE "\n";
        close(NEW);
        return;
    }


    if ( -e "$dir/template" )
    {
        open( TMP, "<", "$dir/template" ) or
          die "Failed to open file $!";
        while ( my $line = <TMP> )
        {
            print FILE $line;
        }
        close(TMP);
    }
    else
    {

        #
        #  Otherwise add the default text, and show it in an editor.
        #
        print FILE<<EOF;
# milli:
# milli:  Enter your bug report here; it is better to write too much than
# milli: too little.
# milli:
# milli:  Lines beginning with "# milli:" will be ignored, and removed,
# milli: this file is saved.
# milli:

EOF
        close(FILE);
    }


    #
    #  Open the file in the users' editor.
    #
    editFile($file);

    #
    #  Re-read the file, and ensure the state + priorities are valid.
    #

    #
    #  Once it was saved remove the lines that mention "# milli: "
    #
    removeMilli($file);

    #
    #  If there is a hook, run it.
    #
    runHook( "add", $file );
}




=begin doc

Search the existing bugs.

Here search means "match against title and status/priority".  Either of which
is optional.

=end doc

=cut

sub cmd_search
{
    my (@args) = (@_);

    #
    #  The search terms, if any.
    #
    my $terms = join( " ", @args );

    #
    #  Get all available bugs.
    #
    my $bugs = getBugs();

    #
    #  The state/priority of bugs the user is interested in.
    #
    my $status   = $CONFIG{ 'state' }    || "all";
    my $priority = $CONFIG{ 'priority' } || "all";

    #
    #  For each bug
    #
    foreach my $bug (@$bugs)
    {

        #
        #  Find basic meta-data.
        #
        my $b_title  = $bug->{ 'title' };
        my $b_uid    = $bug->{ 'uid' };
        my $b_file   = $bug->{ 'file' };
        my $b_number = $bug->{ 'number' };

        #
        #  Priority & state are slightly-special.
        #

        my $b_state = $bug->{ 'status' } ||
          $CONFIG{ 'default-state' } ||
          "open";

        my $b_priority = $bug->{ 'priority' } ||
          $CONFIG{ 'default-priority' } ||
          "normal";


        #
        #  If the user is being specific about status then
        # skip ones that don't match, as this is cheap.
        #
        if ( $status ne "all" )
        {
            next if ( lc($status) ne lc($b_state) );
        }

        #
        #  If the user is being specific about priority then
        # skip ones that don't match, as this is cheap.
        #
        if ( $priority ne "all" )
        {
            next if ( lc($priority) ne lc($b_priority) );
        }

        #
        #  If there are search terms then search the title.
        #
        #  All terms must match.
        #
        my $match = 1;
        if ( length $terms )
        {
            foreach my $term ( split( /[ \t]/, $terms ) )
            {
                if ( $b_title !~ /\Q$term\E/i )
                {
                    $match = 0;
                }
            }
        }

        #
        #  If we didn't find a match move on.
        #
        next unless ($match);

        #
        #  Otherwise show a summary of the bug.
        #
        print sprintf "N:%004d [status:%s priority:%s] %s", $b_number, $b_state,
          $b_priority, $b_title . "\n";

        if ( $CONFIG{ 'verbose' } )
        {
            print "                UID:$bug->{'uid'} Modified:$bug->{'date'}\n";
        }
    }
}



=begin doc

Allow a bug to be updated.

This mostly means:

1.  find the file associated with a given bug.
2.  Allow the user to edit that file.

=end doc

=cut

sub cmd_edit
{
    my (@args) = (@_);

    my $value = join( "", @args );

    #
    #  Ensure we know what we're operating upon
    #
    if ( !length($value) )
    {
        print
          "You must specify a bug to edit, either by the UID, or via the number.\n";
        print "\nFor example to edit bug number 3 you'd run:\n";
        print "\tmilli edit 3\n\n";
        exit 1;
    }

    #
    #  Find the bug.
    #
    my $bug = getBugByUIDORNumber($value);

    #
    #  Edit the file the bug is stored in.
    #
    editFile( $bug->{ 'file' } );

    #
    #  Re-read the file to check for common errors.
    #
    $bug = readBug( $bug->{ 'file' } );


    #
    #  Ensure the status is valid.
    #
    if ( !isStateValid( $bug->{ 'status' } ) )
    {
        print "WARNING:\n";
        print "WARNIGN: INVALID STATUS - $bug->{'status'}\n";
        print "WARNING:\n";
    }

    #
    #  Ensure the priority is valid.
    #
    if ( !isPriorityValid( $bug->{ 'priority' } ) )
    {
        print "WARNING:\n";
        print "WARNIGN: INVALID PRIORITY - $bug->{'priority'}\n";
        print "WARNING:\n";
    }

    #
    #  If there is a hook, run it.
    #
    runHook( "edit", $bug->{ 'file' } );

}



=begin doc

Open an editor with a new block appended to the end of the file.

This mostly means:

   1.  find the file associated with a given bug.

   2.  Append the new text.

   3.  Allow the user to edit that file.

=end doc

=cut

sub cmd_append
{
    my (@args) = (@_);
    my $value = join( "", @args );


    #
    #  Ensure we know what we're operating upon
    #
    if ( !length($value) )
    {
        print
          "You must specify a bug to append to, either by the UID, or via the number.\n";
        print "\nFor example to append text to bug number 3 you'd run:\n";
        print "\tmilli append 3\n\n";
        exit 1;
    }

    #
    #  Get the bug
    #
    my $bug = getBugByUIDORNumber($value);

    #
    #  Open the file.
    #
    open( NEW, ">>", $bug->{ 'file' } ) or
      die "Failed to open file $bug->{'file'} for appending: $!";


    my $date = scalar localtime;

    #
    #  If we were given a message add it, otherwise spawn the editor.
    #
    if ( $CONFIG{ 'message' } )
    {
        print NEW "\nModified:$date\n";
        print NEW $CONFIG{ 'message' };
        print NEW "\n";
        close(NEW);
        return;
    }

    #
    #  Write out the new section
    #
    print NEW <<EOF;

Modified: $date
Status:    $bug->{'status'}
Priority:  $bug->{'priority'}

# milli:
# milli:  Enter your bug update here; it is better to write too much than
# milli: too little.
# milli:
# milli:  Lines beginning with "# milli:" will be ignored, and removed, once
# milli: this file is saved.
# milli:
EOF
    close(NEW);


    #
    #  Allow the user to make the edits.
    #
    editFile( $bug->{ 'file' } );

    #
    #  Once it was saved remove the lines that mention "# milli: "
    #
    removeMilli( $bug->{ 'file' } );

    #
    #  If there is a hook, run it.
    #
    runHook( "append", $bug->{ 'file' } );

}


=begin doc

View a specific bug.

This means:

   1.  Find the file associated with the bug.
   2.  Open it and print it to the console.

=end doc

=cut

sub cmd_view
{
    my (@args) = (@_);

    my $value = join( "", @args );

    #
    #  Ensure we know what we're operating upon
    #
    if ( !length($value) )
    {
        print
          "You must specify a bug to view, either by the UID, or via the number.\n";
        print "\nFor example to view bug number 3 you'd run:\n";
        print "\tmilli view 3\n\n";
        exit 1;
    }

    #
    #  Get the bug.
    #
    my $bug = getBugByUIDORNumber($value);

    #
    #  Show it to the console
    #
    open( FILE, "<", $bug->{ 'file' } ) or
      die "Failed to open file for reading $bug->{'file'} $!";

    while ( my $line = <FILE> )
    {
        print $line;
    }
    close(FILE);

}


=begin doc

Close a given bug.

=end doc

=cut

sub cmd_close
{
    my (@args) = (@_);

    #
    #  Get the bug.
    #
    my $value = join( "", @args );

    #
    #  Ensure we know what we're operating upon
    #
    if ( !length($value) )
    {
        print
          "You must specify a bug to close, either by the UID, or via the number.\n";
        print "\nFor example to close bug number 3 you'd run:\n";
        print "\tmilli close 3\n\n";
        exit 1;
    }

    changeBugState( $value, "closed" );
}


=begin doc

Change the priority of the bug specified to the given string.

=cut

sub cmd_priority
{
    my ( $priority, @bugs ) = (@_);


    if ( ( !$priority ) ||
         ( !scalar @bugs ) )
    {
        print "Usage: milli priority \"priority\" bug#1 bug#2 .. bug#N\n";
        exit 1;
    }


    #
    #  Ensure the priority is valid
    #
    if ( !isPriorityValid($priority) )
    {
        print "The specified priority is invalid: $priority\n";
        print "Valid options are " . join( ",", $CONFIG{ 'priorities' } ) .
          "\n";
        exit 1;
    }

    foreach my $number (@bugs)
    {
        my $bug = getBugByUIDORNumber($number);

        if ( lc( $bug->{ 'priority' } ) eq lc($priority) )
        {
            print "The bug $number already has priority: $priority\n";
        }
        else
        {

            #
            #  Open the file
            #
            open( NEW, ">>", $bug->{ 'file' } ) or
              die "Failed to open file $bug->{'file'} for appending: $!";

            #
            #  Now write out the new priority section.
            #
            my $date = scalar localtime;
            print NEW <<EOF;

Modified: $date
Priority: $priority

EOF

            close(NEW);

            #
            #  If there is a hook, run it.
            #
            runHook( "priority", $priority, $bug->{ 'file' } );
        }
    }

}


=begin doc

Reopen a bug.

=end doc

=cut

sub cmd_reopen
{
    my (@args) = (@_);

    #
    #  Get the bug.
    #
    my $value = join( "", @args );

    #
    #  Ensure we know what we're operating upon
    #
    if ( !length($value) )
    {
        print
          "You must specify a bug to reopen, either by the UID, or via the number.\n";
        print "\nFor example to reopen bug number 3 you'd run:\n";
        print "\tmilli reopen 3\n\n";
        exit 1;
    }

    changeBugState( $value, "open" );

}




###
###  Utility functions.
###
#############################################################################


sub isStateValid
{
    my ($state) = (@_);


    #
    #  We want to ensure that the state is valid.
    #
    my %valid;

    #
    #  See which states are available, either our defaults or the ones
    # read from .milli/config.
    #
    foreach my $value ( split( /,/, $CONFIG{ 'states' } ) )
    {
        $value =~ s/^\s+//;
        $value =~ s/\s+$//;

        next unless ( length($value) );

        $valid{ lc $value } += 1;
    }

    return ( $valid{ $state } );
}


sub isPriorityValid
{
    my ($priority) = (@_);


    #
    #  We want to ensure that the priority is valid.
    #
    my %valid;

    #
    #  See which priorites are available, either our defaults or the ones
    # read from .milli/config.
    #
    foreach my $value ( split( /,/, $CONFIG{ 'priorities' } ) )
    {
        $value =~ s/^\s+//;
        $value =~ s/\s+$//;
        next unless ( length($value) );

        $valid{ lc $value } += 1;
    }

    return ( $valid{ $priority } );
}



=begin doc

Change the statues of an existing bug.

Valid statuses are listed in .milli/config - with the defaults otherwise
being 'open' and 'closed'.

=end doc

=cut

sub changeBugState
{
    my ( $value, $state ) = (@_);

    #
    #  Ensure the status is valid.
    #
    if ( !isStateValid($state) )
    {
        print "The state $state is not valid.  Valid states are:\n";
        print $CONFIG{ 'states' } . "\n";
        exit 1;
    }


    #
    #  Get the bug.
    #
    my $bug = getBugByUIDORNumber($value);

    #
    #  Ensure the bug isn't already in the specified state.
    #
    if ( lc( $bug->{ 'status' } ) eq lc($state) )
    {
        print "The bug is already $state!\n";
        exit 1;
    }

    #
    #  Open the file
    #
    open( NEW, ">>", $bug->{ 'file' } ) or
      die "Failed to open file $bug->{'file'} for appending: $!";

    #
    #  Now write out the new status section.
    #
    my $date = scalar localtime;
    print NEW <<EOF;

Modified: $date
Status: $state

EOF

    close(NEW);

    #
    #  If there is a hook, run it.
    #
    runHook( $state, $bug->{ 'file' } );
}



=begin doc

Attempt to discover the hostname of the current system.

=end doc

=cut

sub findHostname
{

    #
    #  Run each of the following commands to find the hostname,
    # return the first one that produces non-empty results.
    #
    foreach my $cmd ( "uname -n", "hostname", "cat /etc/hostname",
                      "cat /etc/HOSTNAME" )
    {

        #
        #  Run it.
        #
        my $out = `$cmd`;
        if ( defined($out) )
        {

            #
            #  If there were results.
            #
            chomp($out);
            return $out if ( length($out) );
        }
    }

    return ("unknown.system");
}



=begin doc

Generate a system UID.  This should be created with the hostname and
time included, such that collisions when running upon multiple systems
are unlikely.

(A bug will be uniquely referenced by the UID, even though in practise
people will use bug numbers they are prone to change.)

=end doc

=cut

sub randomUID
{

    #
    #  Get the time.
    #
    my ( $time, $microseconds ) = gettimeofday;
    $time = ( $time =~ m/(\d+)/ )[0];
    $microseconds =~ s/\D//g;

    #
    #  The values that feed into the filename.
    #
    my $hostname = findHostname();
    my $unique   = "P$$" . "M$microseconds";
    my $file     = join ".", $hostname, $time, $unique;

    return ($file);
}



=begin doc

Find and return an array of hashes, one for each existing bug.

=end doc

=cut

sub getBugs
{
    my $results;
    my $number = 0;

    my $dir = getMilliDirectory();

    if ( !defined($dir) )
    {
        if ( $CONFIG{ 'force' } )
        {
            $CONFIG{ 'verbose' } && print "Running 'milli init'.\n";
            cmd_init();
            $CONFIG{ 'verbose' } && print "Initialisation complete.\n";
        }
        else
        {
            print "Missing milli directory - run 'milli init' ?\n";
            print "Or add --force to run this automatically\n";
            exit 1;
        }
    }


    foreach my $file ( sort( glob("$dir/*.milli") ) )
    {
        $number += 1;

        my $hash = readBug($file);
        $hash->{ 'number' } = $number;
        push( @$results, $hash );
    }

    return ($results);
}


=begin doc

Return the information about the single bug stored in the specified
file.

=end doc

=cut

sub readBug
{
    my ($file) = (@_);


    my $status;
    my $priority;
    my $title;
    my $uid;
    my $date;

    open( FILE, "<", $file ) or
      die "Failed to read file $file - $!";
    while ( my $line = <FILE> )
    {
        if ( $line =~ /^Title: (.*)/ )
        {
            $title = $1;
            $title =~ s/^\s+|\s+$//g;

        }
        elsif ( $line =~ /^(Added|Modified):(.*)/ )
        {

            $date = $1;
            $date =~ s/^\s+|\s+$//g;

        }
        elsif ( $line =~ /^UID: (.*)/ )
        {
            $uid = $1;
            $uid =~ s/^\s+|\s+$//g;

        }
        elsif ( $line =~ /^Status: (.*)/i )
        {
            $status = $1;
            $status =~ s/^\s+|\s+$//g;
        }
        elsif ( $line =~ /^Priority: (.*)/i )
        {
            $priority = $1;
            $priority =~ s/^\s+|\s+$//g;
        }

    }
    close(FILE);


    #
    #  If we didn't receive an explicit status or priority then
    # we will revert to those listed as the default in .mill/config,
    # or our hard-wired defaults if that doesn't work.
    #

    if ( !$priority )
    {
        $priority = $CONFIG{ 'default-priority' } || "normal";
    }
    if ( !$status )
    {
        $status = $CONFIG{ 'default-status' } || "open";
    }

    return ( { file     => $file,
               uid      => $uid,
               status   => lc $status,
               priority => lc $priority,
               date     => $date,
               title    => $title
             } );

}


=begin doc

Open the given file with either the users editor, the systems editor,
or as a last resort vim.

=end doc

=cut

sub editFile
{
    my ($file) = (@_);

    #
    #  Open the editor
    #
    my $editor = $CONFIG{ 'editor' } || $ENV{ 'EDITOR' } || "vim";
    system( $editor, $file );

}


=begin doc

Remove the "# milli: " prefix from the given file.

=end doc

=cut

sub removeMilli
{
    my ($file) = (@_);

    my @lines;

    #
    #  Open the source file for reading.
    #
    open( FILE, "<", $file ) or
      die "Failed to open $file - $!";

    #
    #  Read it, and store the contents away.
    #
    while ( my $line = <FILE> )
    {
        push( @lines, $line );
    }
    close(FILE);


    #
    #  Open the file for writing.
    #
    open( NEW, ">", $file ) or
      die "Failed to open $file - $!";

    #
    #  Write the contents, removing any lines matching our marker-pattern
    #
    foreach my $line (@lines)
    {
        next if ( $line =~ /^# milli:/ );
        print NEW $line;
    }
    close(NEW);

}



=begin doc

Get the data for a given bug, either by number of UID.

=end doc

=cut

sub getBugByUIDORNumber
{
    my ($arg) = (@_);

    #
    #  Get all bugs.
    #
    my $bugs = getBugs();
    my $bug;

    #
    #  For each one.
    #
    foreach my $possible (@$bugs)
    {

        #
        # If the argument was NNNN then look for that bug number.
        #
        if ( $arg =~ /^([0-9]+)$/i )
        {
            $bug = $possible if ( $1 == $possible->{ 'number' } );
        }
        else
        {

            #
            #  Otherwise look for it by UID
            #
            $bug = $possible if ( lc($arg) eq lc( $possible->{ 'uid' } ) );
        }

        return $bug if ( defined($bug) );
    }

    if ( !defined($bug) )
    {
        print "Bug not found: $arg\n";
        exit 1;
    }

}


=begin doc

We assume that the .milli directory will be in the current
directory - but to be safe we'll search up a couple of levels
too.

=end doc

=cut

sub getMilliDirectory
{
    return (".milli")          if ( -d ".milli" );
    return ("../.milli")       if ( -d "../.milli" );
    return ("../../.milli")    if ( -d "../../.milli" );
    return ("../../../.milli") if ( -d "../../../.milli" );

    return undef;

}


=begin doc

Run a hook.

=end doc

=cut

sub runHook
{
    my (@args) = (@_);

    my $dir = getMilliDirectory();
    if ( ( defined($dir) ) &&
         ( -d $dir ) &&
         ( -x "$dir/hook" ) )
    {
        system( "$dir/hook", @args );
    }
}
